‚≠êGerenciamento de Componentes‚≠ê
Vamos entender como o Spring gerencia os componentes de sua aplica√ß√£o, facilitando a vida do desenvolvedor.

@Component: Use em qualquer classe que voc√™ quer que o Spring gerencie. √â como se fosse o "coringa" das anota√ß√µes.
@Service: Especializa @Component para servi√ßos. Coloque toda a l√≥gica de neg√≥cio aqui. Simplifica a identifica√ß√£o de classes de servi√ßo.
@Repository: Outra especializa√ß√£o de @Component, mas voltada para acesso a dados. √â o bra√ßo direito do seu banco de dados.
@Controller: Gerencia requisi√ß√µes HTTP. A base para construir aplica√ß√µes web.
‚öôÔ∏èConfigura√ß√£o e Beans‚öôÔ∏è
Como configurar e gerenciar os beans, que s√£o os componentes essenciais da sua aplica√ß√£o Spring.

@Configuration: Marca a classe com m√©todos que configuram beans. √â aqui que voc√™ define como seus componentes v√£o se comportar.
@Bean: Dentro de uma classe com @Configuration, use @Bean para dizer ao Spring: "Ei, gerencie esse cara aqui!".
@PropertySource: Adiciona uma fonte de propriedades ao ambiente Spring. Facilita o uso de arquivos de configura√ß√£o externos.
@Value: Injeta valores de propriedades em campos, m√©todos ou par√¢metros de construtor. Super √∫til para configurar valores de forma din√¢mica.
üíâInje√ß√£o de Depend√™nciasüíâ
Simplifique o gerenciamento de depend√™ncias na sua aplica√ß√£o com essas anota√ß√µes.
@Autowired: Muito √∫til! Inje√ß√£o de depend√™ncia autom√°tica. O Spring injeta os objetos necess√°rios sem voc√™ precisar suar.
@Qualifier: Usado junto com @Autowired para resolver ambiguidades quando h√° m√∫ltiplos beans do mesmo tipo. Especifica exatamente qual bean deve ser injetado.
@Lazy: A inje√ß√£o de depend√™ncias acontece de forma pregui√ßosa, ou seja, s√≥ quando realmente necess√°rio. Usado para economizar recursos.
üßôManipula√ß√£o de Requisi√ß√µes Webüßô
Gerencie facilmente as requisi√ß√µes web no Spring.

@RequestMapping: Mapeia as URLs para m√©todos do seu controller. Pode ser usada na classe ou no m√©todo. Essencial para roteamento.
@GetMapping, @PostMapping, @PutMapping, @DeleteMapping: S√£o os verbos HTTP, usados para mandar o tipo da requisi√ß√£o. Facilita a leitura e manuten√ß√£o do c√≥digo.
@RestController: Combina @Controller e @ResponseBody. Indica que a classe lida com requisi√ß√µes REST e retorna dados no corpo da resposta.
@PathVariable: Extrai vari√°veis da URL e passa como par√¢metros para os m√©todos do controller. Pr√°tico para rotas din√¢micas.
@RequestParam: Acessa par√¢metros da requisi√ß√£o. √ötil para capturar dados de requisi√ß√µes GET e POST.
@RequestBody: Converte automaticamente o corpo da requisi√ß√£o HTTP em um objeto Java. Perfeito para APIs REST que lidam com JSON.
@ResponseBody: Indica que o retorno de um m√©todo deve ser serializado diretamente no corpo da resposta HTTP.
üìúTarefas e Transa√ß√µesüìú
Automatize tarefas e gerencie transa√ß√µes de forma eficiente.

@Scheduled: Marca m√©todos para execu√ß√£o em intervalos regulares. Ideal para tarefas autom√°ticas como limpeza de cache.
@Transactional: Garante que m√©todos sejam executados dentro de uma transa√ß√£o de banco de dados. Crucial para manter a consist√™ncia dos dados.
@Async: Permite a execu√ß√£o ass√≠ncrona de m√©todos. Super √∫til para opera√ß√µes que podem ser executadas em paralelo sem bloquear o fluxo principal.
üîêSeguran√ßa e Valida√ß√£oüîê
Implemente seguran√ßa e valida√ß√£o de forma pr√°tica e eficaz.

@Secured: Especifica regras de seguran√ßa em m√©todos. Define quem pode acessar o qu√™.
@PreAuthorize: Uma anota√ß√£o mais poderosa que @Secured, permitindo express√µes complexas para definir regras de seguran√ßa.
@Valid: Usada para ativar a valida√ß√£o de beans no Spring. Garante que os dados est√£o corretos antes de prosseguir com a l√≥gica de neg√≥cios.
üìûChamadas Remotasüìû
Facilite a comunica√ß√£o com servi√ßos externos.

@FeignClient: Marca uma interface como um cliente Feign, permitindo a chamada de servi√ßos remotos de forma declarativa.

@crossorigin √© usada no desenvolvimento web para permitir o compartilhamento de recursos (como imagens ou APIs) entre diferentes dom√≠nios, atrav√©s de uma configura√ß√£o de CORS (Cross-Origin Resource Sharing). Ela √© comumente utilizada no servidor para liberar esse tipo de acesso.

@Data: Gera automaticamente os m√©todos toString(), equals(), hashCode(), al√©m dos getters e setters para todos os campos da classe.

@Builder: Cria um padr√£o de constru√ß√£o (builder) para a classe, permitindo a cria√ß√£o de objetos de forma fluente e leg√≠vel, com a possibilidade de definir valores para os campos de forma personalizada.

@NoArgsConstructor: Gera um construtor sem argumentos para a classe.

@AllArgsConstructor: Gera um construtor com um argumento para cada campo da classe.

@Entity: Marca a classe como uma entidade JPA (Java Persistence API), indicando que ela ser√° mapeada para uma tabela no banco de dados.

@SQLRestriction("habilitado = true"): Especifica uma restri√ß√£o SQL personalizada para a entidade. No caso, filtra os resultados da consulta para retornar apenas as entidades onde o campo habilitado seja true.

@Builder: Gera um padr√£o de constru√ß√£o (builder) para a classe, permitindo criar objetos de forma fluente e personalizada.

@Getter: Gera automaticamente os m√©todos getters para todos os campos da classe.

@Setter: Gera automaticamente os m√©todos setters para todos os campos da classe.

√â boa pr√°tica colocar as anota√ß√µes de valida√ß√£o (como @NotBlank, @CPF, etc.) na classe ClienteRequest, porque elas protegem a aplica√ß√£o desde a entrada.

Na classe Cliente, o foco deve ser em anota√ß√µes de JPA, como @Column, @ManyToOne, etc., que tratam da persist√™ncia e estrutura do banco ‚Äî mas sem responsabilidade de valida√ß√£o de entrada da API.

 Anota√ß√£o	Finalidade
@NotNull	N√£o permite valor null
@NotBlank	N√£o permite string vazia ou com apenas espa√ßos
@Email	Verifica se o e-mail √© v√°lido
@CPF	Verifica se o CPF √© v√°lido conforme regras do Brasil
@JsonFormat	Define o padr√£o de formata√ß√£o da data no JSON
@Column(...)	Define propriedades da coluna no banco (nullable, length, unique)
@ManyToOne	Relacionamento muitos-para-um com outra entidade
@JoinColumn(...)	Define a coluna de jun√ß√£o (chave estrangeira) e suas propriedades

 Quadro resumo com os erros mais comuns por anota√ß√£o
Anota√ß√£o	Erro comum	Como resolver
@NotNull	Valor nulo causa ConstraintViolationException	Certifique-se de que o campo est√° sendo preenchido no JSON enviado.
@NotBlank	Campo preenchido com string vazia ou apenas espa√ßos	Envie valor real e significativo (ex: "Jo√£o" em vez de "" ou " ").
@Email	Valor n√£o √© um e-mail v√°lido (ex: joao@)	Informe e-mails no formato correto: nome@dominio.com.
@CPF	CPF inv√°lido (d√≠gitos errados ou m√°scara incorreta)	Use CPFs v√°lidos e, se necess√°rio, remova pontos e tra√ßos antes.
@JsonFormat	Data com formato incorreto (ex: "2025-07-11" em vez de "11/07/2025")	Use o padr√£o exato definido: "dd/MM/yyyy" no JSON.
@Column(unique = true)	Erro de banco: ConstraintViolationException ou Duplicate entry	Verifique se o valor j√° existe antes de salvar (ex: CPF duplicado).
@JoinColumn(nullable = false)	Relacionamento obrigat√≥rio n√£o informado	Verifique se o campo relacionado (ex: usuario) est√° vindo no JSON.

@Size(max = 30, message = "O telefone alternativo deve ter no m√°ximo 30 caracteres")
 Detalhes sobre a anota√ß√£o @Size
Par√¢metro	Descri√ß√£o
min	(opcional) Tamanho m√≠nimo permitido
max	Tamanho m√°ximo permitido
message	Mensagem personalizada de erro
@Entity
public class Cliente extends EntidadeAuditavel {

    @ManyToOne(optional = false)
    @JoinColumn(name = "empresa_id", nullable = false)
    private Empresa empresa;

    @Column(nullable = false, length = 100)
    private String nome;

    @Column
    private LocalDate dataNascimento;

    @Column(unique = true)
    private String cpf;

    @Column
    private String fone;

    @Column
    private String foneAlternativo;

    @OneToMany(mappedBy = "cliente", orphanRemoval = true, fetch = FetchType.EAGER)
    private List<EnderecoCliente> enderecos;

    // Getters e Setters (ou use Lombok @Getter/@Setter/@Data)
}
@Entity
public class Empresa extends EntidadeAuditavel {

    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Cliente> clientes;

    @Column
    private String site;

    @Column
    private String cnpj;

    @Column
    private String inscricaoEstadual;

    @Column
    private String nomeEmpresarial;

    @Column
    private String nomeFantasia;

    @Column
    private String fone;

    @Column
    private String foneAlternativo;

    // Getters e Setters
}

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

    http
        .httpBasic().disable()
        .csrf().disable()
        .cors().and()
        .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
        .exceptionHandling()
            .authenticationEntryPoint(authenticationEntryPoint)
        .and()
        .authorizeRequests()

        // Libera endpoints p√∫blicos (whitelist + consulta empresa por ID)
        .antMatchers(AUTH_WHITELIST).permitAll()
        .antMatchers(HttpMethod.GET, "/api/empresa/*").permitAll() // <- AQUI!

        // Demais endpoints exigem autentica√ß√£o com role
        .anyRequest()
            .hasAnyAuthority(Usuario.ROLE_CLIENTE, Usuario.ROLE_EMPRESA)

        .and()
        .addFilterBefore(
            new JwtTokenAuthenticationFilter(jwtTokenProvider),
            UsernamePasswordAuthenticationFilter.class
        );

    return http.build();
}

O arquivo .env √© usado para armazenar vari√°veis de ambiente, como senhas, URLs e chaves secretas, fora do c√≥digo-fonte.

1.
 Vantagens:
Mais seguran√ßa (protege dados sens√≠veis)

Facilidade na troca de ambiente (dev, prod)

Melhor organiza√ß√£o e manuten√ß√£o

√â uma boa pr√°tica e geralmente n√£o deve ser versionado com o c√≥digo

spring.datasource.username=${DB_USER}
